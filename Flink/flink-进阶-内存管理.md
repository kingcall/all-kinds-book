[toc]
## 内存管理
- Flink的内存管理机制其实主要就是**减少内存GC，减少OOM并，针对大数据优化空间使用，并支持二进制操作**。
- 基于 JVM 的数据分析引擎面临的一个常见挑战就是如何在内存中存储大量的数据（包括缓存和高效处理）
- Flink 为了避免 JVM 的固有缺陷例如java对象存储密度低，FGC影响吞吐和响应等，实现了自主管理内存。所以目前，越来越多的大数据项目开始自己管理JVM内存了，像 Spark、Flink、HBase，为的就是获得像 C 一样的性能以及避免 OOM 的发生
> Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了

> Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。

> OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。

### 积极的内存管理
#### 内存管理概论
- Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上。由大量的MemorySegment 构成
- MemorySegment 就是 Flink 的内存抽象。默认情况下，一个MemorySegment可以被看做是一个 32kb 大的内存块的抽象。这块内存既可以是JVM里的一个byte[]，也可以是堆外内存（DirectByteBuffer）。
- 它代表了一段固定长度的内存（默认大小为32KB），也是Flink中**最小的内存分配单元，并且提供了非常高效的读写方法**。
- 每条记录都会以序列化的形式存储在一个或多个MemorySegment中。
- 对接从 Java 对象转为 Buffer 的中间对象是另一个抽象 StreamRecord。
- 此外，Flink 大量的使用了堆外内存。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。
- Flink 为了直接操作二进制数据实现了自己的序列化框架。

#### 内存划分
- Flink 中的 Worker 名叫 TaskManager，是用来运行用户代码的 JVM 进程。TaskManager 的内存主要被分成了三个部分：

![image-20210218190454398](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/image-20210218190454398.png)

##### Network Buffers
- 这个是在 TaskManager启动的时候分配的，这是一组主要**用于数据网络传输的内存**
- 每个块是 32K，默认分配 2048 个，可以通过"taskmanager.network.numberOfBuffers"修改

##### Memory Manage pool

- 这是一个由MemoryManager管理的，由众多MemorySegment组成的超大集合。
- Flink 中的算法（如 sort/shuffle/join）会向这个内存池申请MemorySegment，**将序列化后的数据存于其中，使用完后释放回内存池**。
- MemorySegments 在 TaskManager 启动时分配一次，并在 TaskManager关闭时销毁。
- 因此，在 TaskManager 的整个生命周期中，MemorySegment是重用的，而不会被垃圾收集的。
- 默认情况下，池子占了堆内存的 70% 的大小,剩余的 JVM 堆内存用于在任务处理期间实例化的对象，包括由用户定义的函数创建的对象。

> Memory Manager Pool 主要在Batch模式下使用。在Steaming模式下，该池子不会预分配内存，也不会向该池子请求内存块。也就是说该部分的内存都是可以给用户代码使用的。不过社区是打算在 Streaming 模式下也能将该池子利用起来

##### User Code
- 这部分是除了 Memory Manager 之外的内存用于** User code 和 TaskManager 本身的数据结构**。
- 因为这些数据结构一般都很小，所以基本上这些内存都是给用户代码使用的。
- 从GC的角度来看，可以把这里**看成的新生代**，也就是说这里主要都是**由用户代码生成的短期对象**。

##### 正确理解序列化
- 序列化与反序列化可以理解为编码与解码的过程。
- 序列化以后的数据希望占用比较小的空间，而且数据能够被正确地反序列化出来。
- 为了能正确反序列化，序列化时仅存储二进制数据本身肯定不够，需要增加一些辅助的描述信息。此处可以采用不同的策略，因而产生了很多不同的序列化方法。
- Java本身自带的序列化和反序列化的功能，但是辅助信息占用空间比较大，在序列化对象时记录了过多的类信息。
- Flink实现了自己的序列化框架，Flink处理的数据流通常是一种类型，所以可以只保存一份对象Schema信息，节省存储空间。又因为对象类型固定，所以可以通过偏移量存取。

#### 堆外内存
- 启动超大内存（上百GB）的JVM需要很长时间，GC停留时间也会很长（分钟级）。使用堆外内存可以极大地减小堆内存（只需要分配RemainingHeap），**使得TaskManager扩展到上百GB内存不是问题**
- 进行IO操作时，使用堆外内存可以zero-copy，使用堆内内存至少要复制一次。** 堆外内存在进程间是共享的**
- 使用堆外内存可以减少分配内存的限制（时间和空间上），同时可以降低内存的GC。使用堆外内存可以极大地减小堆内存（只需要分配Remaining Heap）

### 对象的操作

#### 传统的操作
- 在 JVM 中处理大量数据最直接的方式就是将这些数据做为对象存储在堆内存中，然后直接在内存中操作这些数据，如果想进行排序则就是对对象列表进行排序。然而这种方法有一些明显的缺点，首先，在频繁的创建和销毁大量对象的时候，监视和控制堆内存的使用并不是一件很简单的事情。
- 如果对象分配过多的话，那么会导致内存过度使用，从而触发 OutOfMemoryError，导致 JVM 进程直接被杀死。另一个方面就是因为这些对象大都是生存在新生代，当 JVM 进行垃圾回收时，垃圾收集的开销很容易达到 50% 甚至更多。

#### Flink 的操作
- Flink 将对象序列化为固定数量的预先分配的内存段，而不是直接把对象放在堆内存上。
- 它的 DBMS 风格的排序和连接算法尽可能多地对**这个二进制数据进行操作，以此将序列化和反序列化开销降到最低**。
- 如果需要处理的数据多于可以保存在内存中的数据，Flink的运算符会将部分数据溢出到磁盘。事实上，很多Flink 的内部实现看起来更像是 C / C ++，而不是普通的 Java

### 优势

#### 减少GC压力
- 因为所有常驻型数据(长生命周期的数据)都以二进制的形式存在 Flink 的MemoryManager中，这些MemorySegment一直呆在老年代而不会被GC回收。
- 其他的数据对象基本上是由用户代码生成的短生命周期对象，这部分对象可以被 Minor GC 快速回收,这大大降低了垃圾收集的压力。
- 只要用户不去创建大量类似缓存的常驻型对象，那么老年代的大小是不会变的，MajorGC也就永远不会发生。从而有效地降低了垃圾回收的压力。
- - 现在，预先分配的内存段是 JVM 堆上的长期存在的对象，为了降低垃圾收集的压力，Flink 社区正在积极地将其分配到堆外内存。
- 这种努力将使得 JVM 堆变得更小，垃圾收集所消耗的时间将更少。

#### 避免了OOM(内存的安全执行)
-  由于分配的内存段的数量是固定的，因此监控剩余的内存资源是非常简单的。在内存不足的情况下，处理操作符可以有效地将更大批的内存段写入磁盘，后面再将它们读回到内存。因此，OutOfMemoryError 就有效的防止了。

#### 节省内存空间
- Java 对象在存储上有很多额外的消耗。如果只存储实际数据的二进制内容，就可以避免这部分消耗。

#### 高效的二进制操作 & 缓存友好的计算
- 二进制数据以定义好的格式存储，可以高效地比较与操作。另外，该二进制形式可以把相关的值，以及hash值，键值和指针等相邻地放进内存中。这使得数据结构可以对高速缓存更友好，可以从 L1/L2/L3 缓存获得性能的提升

> MemorySegment 通过使用 Java 的unsafe方法对其支持的字节数组提供非常有效的读写访问。

> Apache Flink 并不是唯一一个基于 JVM 且对二进制数据进行操作的数据处理系统。例如 Apache Drill、Apache Ignite、Apache Geode 也有应用类似技术，最近 Apache Spark 也宣布将向这个方向演进。

