[toc]
# Java 虚拟机(JVM)

**本节主要了解JVM的主要结构和相关概念，这里就不讨论太多细节,具体可看对应章节**

- "虚拟机"是一个相对于 “物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式。
- 在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型称为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。
- 但从外观上看起来，所有的 Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果，下面将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。
- java 虚拟机是java 一次编译到处运行的基础

## Java 虚拟机的结构
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028174308914.png)
- JVM分为五个主要子系统：
  1. 类加载器子系统
  2. 运行时数据区
  3. 执行引擎
  4. 本地方法接口
  5. 垃圾收集器
  
## Java 虚拟机的功能
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028174315389.png)
1. 不同厂商的Jvm 实现不尽相同，但是从功能上来看大致是一样的，这个也不局限于虚拟机，物理机亦是如此(输入——>处理输入——>输出)
详细流程如下：
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028174534205.png)
## 类加载器
- 虚拟机把描述类的数据从class 文件，加载到内存，并堆数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 
- 类类加机制的功能实现能由类加载器处理。它加载、链接、并在运行时第一次引用类时初始化类文件，而不是编译时。

### 加载
   -BootStrap class Loader，Extension class Loader和Application class Loader是三个类加载器
   - BootStrap ClassLoader - 负责从引导类路径加载类，除了rt.jar。该装载机将获得最高优先权。
   - 扩展类加载器 - 负责加载ext文件夹（jre \ lib）中的类。
   - 应用程序类加载器 -负责加载应用程序级类路径，路径提及的环境变量等
   ```
   上面的类加载器将在加载类文件时遵循授权层次结构算法。——ClassLoader使用的是双亲委托模型来搜索类的，
   每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，
   但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，
   这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，
   如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。
   如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。
   否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。
   ```
   - 除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载

### 链接(以下三个阶段的统称)
     1. 验证 - 字节码验证器将验证生成的字节码是否合适，如果验证失败，我们将得到验证错误。
     2. 准备 - 对于所有静态变量，内存将被分配并分配为默认值。
     3. 解析 - 所有符号存储器引用均被来自方法区域的原始引用替换。

### 初始化
这是类加载的最后阶段，这里所有的静态变量 都将被赋予原始值，并且静态块将被执行。
## Java 运行时数据区(JRE)
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028175002896.png)
运行时数据区分为5个主要组件：

### 方法区
- 所有的类级数据将被存储在这里，包括静态变量。每个JVM只有一个方法区域，它是一个共享资源。
```
方法区是jvm规范中的定义,也就是逻辑上的，不同厂商、不同版本的虚拟机的实现不尽相同，主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
```
### 堆 
- 所有对象及其相应的实例变量和数组将存储在此处。每个JVM还有一个堆区。由于方法区和堆区域共享多个线程的内存，所存储的数据不是线程安全的。
### 栈 
- 对于每个线程，都会创建一个单独的运行时堆栈。对于每个方法调用，将在堆栈内存中创建一个称为堆栈帧的条目。所有局部变量都将在堆栈内存中创建。因为它不是共享资源，所以堆栈区域是线程安全的。堆栈帧分为三个子实体：
    - 局部变量数组 - 与该方法相关的涉及多少个局部变量，并且相应的值将被存储在这里。
    - 操作数栈 - 如果需要执行任何中间操作，操作数堆栈将作为运行时工作空间来执行操作。
    - 帧数据 - 所有与该方法相对应的符号都存储在此处。在任何异常情况下，捕获块信息将保留在帧数据中。
```
线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
```
### 程序计数器
- 每个线程都有独立的程序计数器(基于PC寄存器)，一旦执行指令就保存当前执行指令的地址，程序计数器将用下一条指令更新。

### 本地方法栈 
- 本机方法堆栈包含本机方法信息。对于每个线程，都会创建一个单独的本地方法堆栈。
```
区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，
而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。
```
- 整个JVM 运行时数据区如图所示
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028175013409.png)

## 执行引擎
### 执行引擎的主要结构
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028175341061.png)
- 执行引擎是Java虚拟机最核心的组成部分之一，“虚拟机”是一个相对于“物理机”的概念，这两种机器都具有执行代码的能力。其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
#### 解释器 
  - 解释器解释字节码的速度更快，但执行速度较慢。解释器的缺点是，当多次调用一种方法时，每次都需要新的解释。
#### JIT编译器
  - JIT编译器中和了解释器的缺点。执行引擎将在转换字节码时使用解释器的帮助，但是当它发现重复的代码时，它将使用JIT编译器，它编译整个字节码并将其更改为本地代码。该本机代码将直接用于重复的方法调用，这可以提高系统的性能。
#### 中间代码生成器 
  - 生成中间代码
#### 代码优化器 
  - 负责优化上面生成的中间代码
#### 目标代码生成器 - 
  - 负责生成机器代码或本地代码
#### Profiler 
  - 一个特殊的组件，负责查找热点，即该方法是否被多次调用。
#### 垃圾收集器
  - 收集并删除未引用的对象。垃圾回收可以通过调用“System.gc（）”触发，但执行不能保证。JVM的垃圾收集收集所创建的。
#### Java本地接口（JNI）
  - JNI将与本地方法库交互并提供执行引擎所需的本地库。
#### 本地方法库
  - 它是执行引擎所需的本地库集合。

## 一次编译到处运行的终极奥义
- 一次编译到处运行的前提是到处安装JVM
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028223732413.png)
### 第一次编译
- Java源代码——>.CLASS文件字节码，是java的第一次编译。生成的这个.class文件就是可以到处运行的文件。
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028223745904.png)
### 第二次编译(解释)
- Java字节码——>目标机器代码；执行是由JVM执行引擎来完成，JAVA的第二次编译(解释),所以整体流程如下:
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028223840518.png)
- 所以看到这里其实就明白了,"一次编译,到处运行"的先决条件不止是有虚拟机，还需要虚拟机的二次解释，才能真正的被操作系统执行,对比普通程序的执行,多了虚拟机这一环节
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191028223857752.png)

```
1. 过了JAVA的两次编译，不要以为JAVA是编译机制，在java中有第一次编译，还有第二次解释来适应不同平台；根据不同的平台进行解释执行。在JVM中的第二次编译过程中
（从字节码向机器码转换过程中）真正采用的是“解释”机制。即翻译一句，执行一句，不产生整个的机器代码程序。翻译过程如果不出现错误，就一直进行到完毕，否则将在错误处停
止执行。

2. 同一个程序，如果是解释执行的，那么它的运行速度通常比编译为可执行的机器代码的运行速度慢一些。但是，对Java来说，二者的差别不太大。
3. Java的字节码经过仔细设计，很容易便能使用JIT即时编译方式编译技术将字节码直接转化成高性能的本地机器码，Sun 公司在 Java发行版中提供了这样一个字节码编译器——JIT（JustInTime）它是Java虚拟机的一部分。

4. 程序一旦交给虚拟机之后，到底是解释执行还是编译执行，就由虚拟机本身决定了。
```

![JVM](https://kingcall.oss-cn-hangzhou.aliyuncs.com/blog/img/1891611.png)

## 方法执行的理论过程

### 方法执行的内存模型
- 方法的执行内存模型就是栈
- 方法是被封装在线程里，交给CPU 的某个内核去执行的，方法的执行和退出对应的就是一个栈帧的入栈和出栈，栈帧保存的就是这个方法所需的一切变量(入参，返回值和方法里面定义的变量)和对方法的链接以及方法的返回地址(可以先记着，后面的文章会详细解释)；栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。
- Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器(程序计数器)。
- 当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。
### 方法执行的基本流程
![](https://soaringbirdblog.oss-cn-shanghai.aliyuncs.com/oneblog/20191030100646377.png)

- 我们知道Java的字节码是不被硬件所识别的，所以为了能被硬件支持，这个java 虚拟机会对字节码进行二次编译（第一次编译发生在java代码转换成字节码的过程）
- 这里的编译，有两种情况，一种是真正的编译，就像是java代码转换成字节码一样，直接编译成机器码；还有一种是解释执行，就是遇到一个指令，就解释一个指令使其成为机器码，然后执行。
- 解释执行 执行时才翻译成机器指令，无需保存不占内存。但即时编译类似预编译，编译之后的指令需要保存在内存中，这种方式吃内存，按照二八原则这种混合模式最恰当的，热点代码编译之后放入内存避免重复编译，而其他运行次数较少代码则解释执行，避免占用过多内存
- 前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译

# 总结
1. 了解java 虚拟机的主要组成和程序运行的基本流程
2. 虚拟机主要有三大组件——类加载器、运行时数据区、执行引擎
3. 虚拟机对应的是物理机,虚拟机是Java 的"一次编译,到处运行"的基础，也就是说到处运行的前提就是到处都有虚拟机
4. 由于虚拟机的引入，可以避免代码对硬件和操作系统的适配，这个时候JVM 就相当于适配器，针对不同的平台，将字节码解释成对应的机器码，然后交给硬件去执行，可以轻松实现Java代码的跨平台执行
5. 虚拟机的另外一个好处是它带来了一个托管环境（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。
