[toc]
## 功能
- 通过程序计数器的值来确定下一条要执行的指令(字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令)
- 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器完成

## 出现背景
- 指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。
- 假设程序永远只有一个线程，也就是说并不需要程序计数器。

### 多线程环境
- JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说则是一个内核）都只会执行一条线程中的指令
- 也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置——这个就是程序计数器的功能
- 在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，为了线程切换之后能够恢复到一个正确的执行位置，每条线程都需要有一个独立的程序计数器，即具备线程隔离的特性，各条线程之间计数器互不影响，独立存储（我们称这一类内存区域为“线程私有”的内存）。

## 特点
- 线程私有
- 没有内存溢出
> 程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计
> 程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域,程序计数器，保存的是当前执行的字节码的偏移地址。当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，**并不需要申请新的内存来保存新的指令地址**因此，永远都不可能内存溢出的。

### 程序计数器的值
- 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
- 如果正在执行的是Native方法，这个计数器的值为空（Undefined）
> 执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，

- 线程计数器，必须是线程被创建开始执行的时候，就要一同被创建。一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了
