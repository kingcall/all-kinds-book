[toc]
## 序列化(serializable)
- 类通过实现java.io.serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。
- 序列化接口没有方法或字段，**仅用于标识可序列化的语义**。

### 背景
- 对象序列化的最主要的用处就是在传递,和保存对象(object)的时候,保证对象的完整性和可传递性。
- 本质 上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。序列化机制的核心作用就是对象状态的 保存与重建。

#### 序列化
- 是指把对象转换成**有序字节流**，以便在网络上传输或者保存在本地文件中
- 序列化后的字节流保存了Java对象的状态以及相关的描述信息

#### 反序列化
- 客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。

### 实现过程
- 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

#### 实现方法
- 将对象实例相关的类元数据输出。
- 递归地输出类的超类描述直到不再有超类。
- 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。
- 从上至下递归输出实例的数据

#### 序列化注意事项
- 序列化时，只对对象的状态进行保存，而不管对象的方法
- 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口
- 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化
- 并非所有的对象都可以序列化，至于为什么不可以，有很多原因
    - 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输等，**在序列化进行传输的过程中，这个对象的private等域是不受保护的**
    - 声明为static和transient类型的成员数据不能被序列化。**因为static代表类的状态，transient代表对象的临时数据。**

### transient
- 用transient关键字标记的成员变量不参与序列化过程
- 可以实现writeObject，writeObject 对默认的序列化行为进行干预，也就是可以满足自定义写需求

### serialversionuid
- 序列化运行时使用一个称为serialversionuid的版本号与每个**可序列化类相关联**
- 该序列号在反序列化过程中*用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类*。
- 如果接收者加载的该对象的类的serialversionuid与对应的发送者的类的版本号不同，则反序列化 将会导致invalidclassexception。
- 可序列化类可以通过声明名为"serialversionuid"的字段（该字段必须是静态 (static)、最终(final)的long型字段）显式声明其自己的serialversionuid
- 如果可序列化类未显式声明serialversionuid，则序列化运行时将基于该类的各个方面计算该类的默认serialversionuid值
- 不过，**强烈建议所有可序列化类都显式声明serialversionuid值，原因计算默认的 serialversionuid对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别**，这样在反序列化过程中可能会导致意外的 invalidclassexception。
- 因此，为保证serialversionuid值跨不同java编译器实现的一致性，序列化类必须声明一个 明确的serialversionuid值。还强烈建议使用private修改器显示声明serialversionuid（如果可能），原因是这种声明 仅应用于立即声明类--serialversionuid字段作为继承成员没有用处
> local class incompatible: stream classdesc serialVersionUID = -1156649825120724362, local class serialVersionUID = -4191172496954283789

## 外部化(externalization)
- 外部化和序列化是实现同一目标的两种不同方法