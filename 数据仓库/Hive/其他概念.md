[toc]
## 本地模式
-  0.7版本后Hive开始支持任务执行选择本地模式(local mode)。
-  大多数的Hadoop job是需要hadoop提供的完整的可扩展性来处理大数据的。
-  不过，有时hive的输入数据量是非常小的。在这种情况下，为查询出发执行任务的时间消耗可能会比实际job的执行时间要多的多。对于大多数这种情况，hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间会明显被缩短。

### 使用
-  set hive.exec.mode.local.auto=true;(默认为false)

### 使用条件
1. job的输入数据大小必须小于参数：hive.exec.mode.local.auto.inputbytes.max(默认128MB)
2. job的map数必须小于参数：hive.exec.mode.local.auto.tasks.max(默认4)
3. job的reduce数必须为0或者1

## 内部表和外部表区别
- 创建表时：创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变
- 删除表时：在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。**这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据**。

## 分区和分桶的区别

### 分区
#### 分区的意义
- 是指按照数据表的某列或某些列分为多个区，**区从形式上可以理解为文件夹**，比如我们要收集某个大型网站的日志数据，一个网站每天的日志数据存在同一张表上，由于每天会生成大量的日志，导致数据表的内容巨大，在查询时进行全表扫描耗费的资源非常多。
- 那其实这个情况下，我们可以按照日期对数据表进行分区，不同日期的数据存放在不同的分区，在查询时只要指定分区字段的值就可以直接从该分区查找

##### 方便管理
##### 提高性能
- 枝剪——分区消除

#### 注意事项
- 不要创建过多的分区，影响了数据加载和数据检索的能力
- 避免分区小于1GB
- 分区数量较多时，调整HiveServer2 和 MetaStore 的内存大小
- 分区不要嵌套太深——分区数目多
- 如果要将数据插入多个分区，就需要开启动态分区
- 要求你的分区键不会出现大量小分区，且按键分区最好均匀

### 分桶
- 分桶是相对分区进行更细粒度的划分。
- 分桶将整个数据内容按照某列属性**hash值进行区分**，如要按照name属性分为3个桶，就是对name属性值的hash值对3取摸，按照取模结果对数据分桶。
- 如取模结果为0的数据记录存放到一个文件，取模为1的数据存放到一个文件，取模为2的数据存放到一个文件

#### 分桶的意义
- 获得更高的查询处理效率。桶为表加上了额外的结构，Hive在处理有些查询时能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用Map端连接（Map-sidejoin）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。
- 使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便
- 对于map端连接的情况，两个表以相同方式划分桶。处理左边表内某个桶的mapper知道右边表内相匹配的行在对应的桶内。因此，mapper只需要获取那个桶 (这只是右边表内存储数据的一小部分)即可进行连接。这一优化方法并不一定要求两个表必须桶的个数相同，两个表的桶个数是倍数关系也可以。 

#### 场景
- 利于抽样
- 利于join

#### 注意事项
##### 注意数据倾斜
- 选择唯一值个数较多的列作为分桶的键
- 为倾斜的值，单独创建分桶，可以采用列表分桶

##### 桶的个数
- 一般情况 1 个 CPU 只会对一个桶的数据进行写入，所以要保证桶的个数比较多
- 对于 join 而言，要保证分桶键相同，并且桶的个数是倍数关系

## Strict Mode
- hive.mapred.mode=true，严格模式不允许执行以下查询：
    - 分区表上没有指定了分区
    - 没有limit限制的order by语句
    - 笛卡尔积：JOIN时没有ON语句

## Combiner聚合
- hive.map.aggr=true;在map中会做部分聚集操作，效率更高但需要更多的内存。
- hive.groupby.mapaggr.checkinterval：在Map端进行聚合操作的条目数目